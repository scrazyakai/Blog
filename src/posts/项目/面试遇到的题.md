---
title: 面试遇到的题
date: 2025/08/25
categories:
 - posts
tags:
 - FindCompanions项目
---
# 面试遇到的题
## 打印树

### 题目描述

>给定一组节点，每个节点包含以下信息：
>
>- `id`：节点编号（唯一标识）。
>- `parentId`：父节点编号（如果 `parentId = 0`，表示根节点）。
>- `name`：节点名称。
>
>请根据这些节点关系构建一棵（或多棵）树，并以缩进的形式打印树结构。
>
>------
>
>### 示例输入
>
>```
>[
> (1, 0, "AA"),
> (2, 1, "BB"),
> (3, 1, "CC"),
> (4, 3, "DD"),
> (5, 3, "EE"),
> (6, 2, "FF"),
> (7, 2, "GG"),
> (8, 4, "HH"),
> (9, 5, "II"),
> (10, 0, "JJ"),
> (11, 10, "KK"),
> (12, 10, "LL"),
> (13, 12, "MM"),
> (14, 13, "NN"),
> (15, 14, "OO")
>]
>```
>
>------
>
>### 示例输出
>
>```
>AA
>  BB
>    FF
>    GG
>  CC
>    DD
>      HH
>    EE
>      II
>JJ
>  KK
>  LL
>    MM
>      NN
>        OO
>```

```java
package InterviewProblems;

import java.util.*;

public class ShowMeBug {
    static class Node {
        int id;
        int parentId;
        String name;

        public Node(int id, int parentId, String name) {
            this.id = id;
            this.parentId = parentId;
            this.name = name;
        }
    }

    public static void main(String[] args) {
        List<Node> nodeList = Arrays.asList(
                new Node(1, 0, "AA"),
                new Node(2, 1, "BB"), 
                new Node(3, 1, "CC"),
                new Node(4, 3, "DD"), 
                new Node(5, 3, "EE"),
                new Node(6, 2, "FF"), 
                new Node(7, 2, "GG"),
                new Node(8, 4, "HH"), 
                new Node(9, 5, "II"),
                new Node(10, 0, "JJ"), 
                new Node(11, 10, "KK"),
                new Node(12, 10, "LL"),
                new Node(13, 12, "MM"),
                new Node(14, 13, "NN"),
                new Node(15, 14, "OO")
        );
        print(nodeList);
    }

    public static void print(List<Node> nodeList) {
        Map<Integer,List<Node>> map = new HashMap<>();
        for(Node node : nodeList){
            if(!map.containsKey(node.parentId)){
                map.put(node.parentId, new ArrayList<Node>());
            }
            map.get(node.parentId).add(node);
        }
        printTree(map, 0, 0);
    }

    private static void printTree(Map<Integer, List<Node>> map, int parentId, int depth) {
        List<Node> children = map.get(parentId);
        if(children == null){
            return;
        }
        for(Node node : children){
            StringBuilder sb = new StringBuilder();
            for(int i = 0; i < depth;i++){
                sb.append("  ");  // 两个空格缩进
            }
            System.out.println(sb.toString() + node.name);
            printTree(map, node.id, depth + 1);
        }
    }

}
```

## 多线程打印0-200

```java
public class Main {
    private static final int MAX = 200;
    private static int num = 0;
    private static final Object lock = new Object();
    private static boolean flag = true;

    static void print() {
        Thread thread1 = new Thread(() -> {
            while (true) {
                synchronized (lock) {
                    while (!flag) { // 等待轮到线程1
                        try {
                            lock.wait();//释放锁，并等待
                        } catch (InterruptedException e) {
                            throw new RuntimeException(e);
                        }
                    }
                    if (num > MAX) {
                        lock.notifyAll();//唤醒在等待的线程
                        break;
                    }
                    System.out.println("线程1: " + num++);
                    flag = false; // 切换到线程2
                    lock.notifyAll();//唤醒在等待的线程
                }
            }
        });

        Thread thread2 = new Thread(() -> {
            while (true) {
                synchronized (lock) {
                    while (flag) { // 等待轮到线程2
                        try {
                            lock.wait();
                        } catch (InterruptedException e) {
                            throw new RuntimeException(e);
                        }
                    }
                    if (num > MAX) {
                        lock.notifyAll();//唤醒在等待的线程
                        break;
                    }
                    System.out.println("线程2: " + num++);
                    flag = true; // 切换到线程1
                    lock.notifyAll();//唤醒在等待的线程
                }
            }
        });

        thread1.start();
        thread2.start();
    }

    public static void main(String[] args) {
        print();
    }
}


```

创建多线程的方法

①继承Thread

```java
public class Main {
    static class MyThread extends Thread{
        @Override
        public void run(){
            System.out.println("hello");
        }
    }

    public static void main(String[] args) {
        Thread thread = new MyThread();
        thread.start();
        System.out.println("你好");
    }

}
```

②实现Runable

```java
public class Main {
    static class MyThread implements Runnable{
        @Override
        public void run(){
            System.out.println("hello");
        }
    }

    public static void main(String[] args) {
        Thread thread = new Thread(new MyThread());
        thread.start();
        System.out.println("你好");
    }

}
```

③实现lambda

```java
public class Main {
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            System.out.println(Thread.currentThread().getName() + " 执行");
        });
        t1.start();
    }
}
```





## SQL语句

### 一、数据库操作

- **CREATE DATABASE**：创建数据库

  ```
  CREATE DATABASE test_db;
  ```

- **DROP DATABASE**：删除数据库

  ```
  DROP DATABASE test_db;
  ```

- **USE**：切换数据库

  ```
  USE test_db;
  ```

------

### 📌 二、数据表操作

- **CREATE TABLE**：创建表

  ```
  CREATE TABLE users (
      id INT PRIMARY KEY AUTO_INCREMENT,
      name VARCHAR(50) NOT NULL,
      age INT,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  );
  ```

- **DROP TABLE**：删除表

  ```
  DROP TABLE users;
  ```

- **ALTER TABLE**：修改表结构

  ```
  ALTER TABLE users ADD email VARCHAR(100);
  ALTER TABLE users DROP COLUMN age;
  ALTER TABLE users MODIFY name VARCHAR(100);
  ```

------

### 📌 三、数据操作（增删改查）

- **INSERT INTO**：插入数据

  ```
  INSERT INTO users (name, age) VALUES ('Alice', 20);
  ```

- **UPDATE**：更新数据

  ```
  UPDATE users SET age = 25 WHERE name = 'Alice';
  ```

- **DELETE**：删除数据

  ```
  DELETE FROM users WHERE name = 'Alice';
  ```

- **SELECT**：查询数据

  ```
  SELECT id, name, age FROM users;
  SELECT * FROM users WHERE age > 18;
  ```

------

### 📌 四、查询关键字

- **DISTINCT**：去重

  ```
  SELECT DISTINCT age FROM users;
  ```

- **WHERE**：条件

  ```
  SELECT * FROM users WHERE age >= 18;
  ```

- **AND / OR / NOT**：逻辑运算

  ```
  SELECT * FROM users WHERE age > 18 AND name = 'Alice';
  ```

- **ORDER BY**：排序

  ```
  SELECT * FROM users ORDER BY age DESC;
  ```

- **LIMIT**：限制条数（MySQL 用法）

  ```
  SELECT * FROM users LIMIT 5;
  ```

- **BETWEEN**：范围查询

  ```
  SELECT * FROM users WHERE age BETWEEN 18 AND 25;
  ```

- **IN**：集合查询

  ```
  SELECT * FROM users WHERE name IN ('Alice', 'Bob');
  ```

- **LIKE**：模糊查询

  ```
  SELECT * FROM users WHERE name LIKE 'A%';  -- 以 A 开头
  SELECT * FROM users WHERE name LIKE '%e';  -- 以 e 结尾
  ```

------

### 📌 五、聚合与分组

- **COUNT / SUM / AVG / MAX / MIN**

  ```
  SELECT COUNT(*) FROM users;
  SELECT AVG(age) FROM users;
  ```

- **GROUP BY**：分组

  ```
  SELECT age, COUNT(*) FROM users GROUP BY age;
  ```

- **HAVING**：对分组后的结果过滤（区别于 WHERE）

  ```
  SELECT age, COUNT(*) AS cnt FROM users GROUP BY age HAVING cnt > 1;
  ```

------

### 📌 六、连接查询（JOIN）

- **INNER JOIN**（内连接）

  ```
  SELECT u.id, u.name, o.order_id
  FROM users u
  INNER JOIN orders o ON u.id = o.user_id;
  ```

- **LEFT JOIN**（左连接）

  ```
  SELECT u.id, u.name, o.order_id
  FROM users u
  LEFT JOIN orders o ON u.id = o.user_id;
  ```

- **RIGHT JOIN**（右连接）

  ```
  SELECT u.id, u.name, o.order_id
  FROM users u
  RIGHT JOIN orders o ON u.id = o.user_id;
  ```

------

### 📌 七、子查询

- **子查询（Subquery）**

  ```
  SELECT name FROM users WHERE id IN (
      SELECT user_id FROM orders WHERE amount > 100
  );
  ```

------

### 📌 八、其他常见关键字

- **AS**：别名

  ```
  SELECT name AS username FROM users;
  ```

- **UNION / UNION ALL**：合并查询结果

  ```
  SELECT name FROM users
  UNION
  SELECT name FROM employees;
  ```

- **EXISTS**：是否存在

  ```
  SELECT * FROM users u WHERE EXISTS (
      SELECT 1 FROM orders o WHERE o.user_id = u.id
  ```

CONCAT() - 将多个字符串连接成一个字符串。

CHAR_LENGTH() - 返回字符串的长度（以字符为单位）。

## 不想让方法抛出异常该怎么办

转化为运行时异常

```java
public String readFile(String path) {
    try {
        return Files.readString(Path.of(path));
    } catch (IOException e) {
        throw new RuntimeException("文件读取失败", e);
    }
}

```

## 实现一个方法，统计指定文件中单词的个数

这里用字符流

```java
public int countWords(String filePath) throws IOException {
    int cnt = 0;
    File file = new File(filePath);
    BufferedReader reader = new BufferedReader(new FileReader(file));
    String line;
    while ((line = reader.readLine()) != null) {
        String[] strs = line.split("\\s+"); // 按空白符切分
        for (String s : strs) {
            if (s.isEmpty() || s.equals(",") || s.equals(".")) {
                continue;
            }
            cnt++;
        }
    }
    reader.close();
    return cnt;
}
```

- **字节流（byte 为单位）**
  - 基类：`InputStream` / `OutputStream`
  - 用来处理二进制数据（图片、音频、视频、压缩包…）
  - **常见类**：
    - `FileInputStream` / `FileOutputStream`（文件字节流）
    - `BufferedInputStream` / `BufferedOutputStream`（带缓冲，提高效率）
- **字符流（char 为单位）**
  - 基类：`Reader` / `Writer`
  - 用来处理文本数据（纯文字文件，如 `.txt`、`.java`）
  - **常见类**：
    - `FileReader` / `FileWriter`（文件字符流）
    - `BufferedReader` / `BufferedWriter`（带缓冲，可以 `readLine()`
- **普通流**：一次读写就访问底层文件系统，效率相对低
- **缓冲流**：在内存中加了一层缓存区（默认 8KB），减少磁盘访问次数，效率更高
  - `BufferedInputStream`、`BufferedOutputStream`
  - `BufferedReader`、`BufferedWriter`

怎么实现项目中缓存一致性的？

1. 第一次删除：在更新数据库前，先删除缓存。

2.  2更新数据库：执行数据库的写操作。

3.   延迟等待：等待一段时间（通常为主从同步延迟时间 + 少量缓冲时间）。 

4. 第二次删除：再次删除缓存。

    第一次删除的目的是为了清除缓存旧值，强制后续读请求直接访问数据库（避免直接返回旧缓存）。

    第二次删除（延迟后）的目的是为了清除在数据库更新期间可能被其他请求写入的旧缓存值
