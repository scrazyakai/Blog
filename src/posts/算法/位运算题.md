---
title: 位运算写题
icon: pen-to-square
date: 2025-8-18
categories:
 - 算法
tags:
 - 位运算

---
[67. 二进制求和 - 力扣（LeetCode）](https://leetcode.cn/problems/add-binary/?envType=study-plan-v2&envId=top-interview-150)


>给你两个二进制字符串 `a` 和 `b` ，以二进制字符串的形式返回它们的和。
>
> 
>
>**示例 1：**
>
>```
>输入:a = "11", b = "1"
>输出："100"
>```
>
>**示例 2：**
>
>```
>输入：a = "1010", b = "1011"
>输出："10101"
>```
>
> 
>
>**提示：**
>
>- `1 <= a.length, b.length <= 104`
>- `a` 和 `b` 仅由字符 `'0'` 或 `'1'` 组成
>- 字符串如果不是 `"0"` ，就不含前导零

```java
class Solution {
    public String addBinary(String a, String b) {
        StringBuilder sb = new StringBuilder();
        int i = a.length() - 1, j = b.length() - 1, carry = 0;
        while(i >= 0 || j >= 0 || carry > 0){
            int sum = carry;
            if(i >= 0) sum += a.charAt(i--) - '0';
            if(j >= 0) sum += b.charAt(j--) - '0';
            sb.append(sum % 2);
            carry =sum / 2;
        }
        return sb.reverse().toString();
    }
}
```

[201. 数字范围按位与 - 力扣（LeetCode）](https://leetcode.cn/problems/bitwise-and-of-numbers-range/?envType=study-plan-v2&envId=top-interview-150)

>给你两个整数 `left` 和 `right` ，表示区间 `[left, right]` ，返回此区间内所有数字 **按位与** 的结果（包含 `left` 、`right` 端点）。
>
> 
>
>**示例 1：**
>
>```
>输入：left = 5, right = 7
>输出：4
>```
>
>**示例 2：**
>
>```
>输入：left = 0, right = 0
>输出：0
>```
>
>**示例 3：**
>
>```
>输入：left = 1, right = 2147483647
>输出：0
>```
>
> 
>
>**提示：**
>
>- `0 <= left <= right <= 231 - 1`
>
>

```java
class Solution {
    public int rangeBitwiseAnd(int left, int right) {
        int res = 0;
        while(left < right){
            left >>= 1;
            right >>= 1;
            res++;
        }
        return left << res;
    }
}
```

[190. 颠倒二进制位 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-bits/?envType=study-plan-v2&envId=top-interview-150)

>颠倒给定的 32 位无符号整数的二进制位。
>
>**提示：**
>
>- 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
>- 在 Java 中，编译器使用[二进制补码](https://baike.baidu.com/item/二进制补码/5295284)记法来表示有符号整数。
>
> 
>
>**示例 1：**
>
>**输入：**n = 43261596
>
>**输出：**964176192
>
>**解释：**
>
>| 整数      | 二进制                           |
>| --------- | -------------------------------- |
>| 43261596  | 00000010100101000001111010011100 |
>| 964176192 | 00111001011110000010100101000000 |
>
>**示例 2：**
>
>**输入：**n = 2147483644
>
>**输出：**1073741822
>
>**解释：**
>
>| 整数       | 二进制                           |
>| ---------- | -------------------------------- |
>| 2147483644 | 01111111111111111111111111111100 |
>| 1073741822 | 00111111111111111111111111111110 |
>
> 
>
>**提示：**
>
>- `0 <= n <= 231 - 2`
>- `n` 为偶数
>
>

```java
class Solution {
    public int reverseBits(int n) {
        int res = 0;
        for(int i = 0; i < 32;i++){
            res <<= 1;
            res |= (n & 1);
            n >>= 1;
        }
        return res;
    }
}
```

[136. 只出现一次的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/single-number/description/?envType=study-plan-v2&envId=top-interview-150)

用到了a ^ a = 0, a ^ 0 = a

>给你一个 **非空** 整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
>
>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。
>
> 
>
>**示例 1 ：**
>
>**输入：**nums = [2,2,1]
>
>**输出：**1
>
>**示例 2 ：**
>
>**输入：**nums = [4,1,2,1,2]
>
>**输出：**4
>
>**示例 3 ：**
>
>**输入：**nums = [1]
>
>**输出：**1

```java
class Solution {
    public int singleNumber(int[] nums) {
        int single = 0;
        for (int num : nums) {
            single ^= num;
        }
        return single;
    }
}
```

[137. 只出现一次的数字 II - 力扣（LeetCode）](https://leetcode.cn/problems/single-number-ii/description/?envType=study-plan-v2&envId=top-interview-150)

>给你一个整数数组 `nums` ，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次 。**请你找出并返回那个只出现了一次的元素。
>
>你必须设计并实现线性时间复杂度的算法且使用常数级空间来解决此问题。
>
> 
>
>**示例 1：**
>
>```
>输入：nums = [2,2,3,2]
>输出：3
>```
>
>**示例 2：**
>
>```
>输入：nums = [0,1,0,1,0,1,99]
>输出：99
>```
>
> 
>
>**提示：**
>
>- `1 <= nums.length <= 3 * 104`
>- `-231 <= nums[i] <= 231 - 1`
>- `nums` 中，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次**
>
>

出现三次的数字，不管是哪一位，它们的 1 出现次数一定是 3 的倍数。每一位对3取余就是出现过一次的每一位

```java
class Solution {
    public int singleNumber(int[] nums) {
        int[] counts = new int[32];
        for(int i = 0; i < nums.length;i++){
            for(int j = 0; j < 32;j++){
            counts[j] += nums[i] & 1;
            nums[i] >>= 1;
            }
        }
        int res = 0,m = 3;
        for(int i= 0; i < 32;i++){
            res <<= 1;
            res |= counts[31 - i] % m;
        }
        return res;
    }
}
```

